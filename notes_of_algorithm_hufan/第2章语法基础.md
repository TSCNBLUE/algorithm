



## 第2章 C/C++快速入门

### 基础输入输出、函数、循环

1、在C++标准中，stdio.h 更推荐使用等价写法：cstdio。

​		#include<stdio.h>与 #include<cstdio>等价

2、看到题目要求10^9以内或者说32位整数，就用int型来存放；如果是10^18以内或者说64位整数，就用long long型来存放。

3、%f是float和double型的输出格式

4、对于浮点型，不要用float，碰到浮点型就用double存储

5、%c是char型的输出格式

6、\0代表空字符NULL，其ASCII码为0，\0不是空格

7、字符串常量可以作为初值赋给字符数组，并使用%s的格式输出

8、#define pi 3.14和const double pi = 3.14都可以，推荐使用const

9、位运算符的优先级没有算术运算高

10、赋值运算可以通过将其他运算符放在前面来实现赋值操作的简化

11、除%c外，scanf对其他格式符（如%d）的输入是以空白符（即空格、Tab）为结束判断标志。除非用%c把空格按字符读入，其他情况都会自动跳过空格。

12、字符数组使用%s读入的时候以空格跟换行为读入结束的标志

13、在scanf中使用&n，printf不需要&（字符数组不需要）

14、对于double类型的变量，其输出格式变成了%f，而在scanf中却是%lf

15、%md可以使不足m位的int型变量以m位进行右对齐输出，高位用空格补齐；如果本身超过m位，则保持原样

16、%0md，变量不足m位时，高位用0补齐

17、%.mf可以让浮点数保留m位小数输出（这个保留使用的是精度的四舍六入五成双规则）

18、getchar可以识别换行符

19、常用math函数：

​			①fabs（double x）：对于double变量x取绝对值

​			②floor（double x)：向下取整； ceil（double x）向上取整； 返回double类型

​			③pow（double r，double p）：返回r^p

​			④sqrt（double x）：返回x的算术平方根

​			⑤log（double x）：返回以自然对数为底的对数 （C语言中没有对任意底数求对数的函数，必须用换底公式转换）

​			⑥sin(double x)、cos(double x)和tan(double x)：参数是弧度制，返回正弦、余弦、正切值

​			⑦asin(double x)、acos(double x)、atan(double x)：返回double型变量的反正弦、反余弦、反正切值

​			⑧round(double x)：四舍五入

20、switch case里记得写break

21、do…while语句中while后有分号

22、break：直接退出循环

​		continue：临时结束循环的当前轮回

### 数组

#### 一维数组

**定义**：数据类型 数组名[数组大小];   (数组大小必须是常量)

未被赋初值的元素将会由不同编译器内部实现的不同而被赋以不同的初值（可能是很大的随机数），一般情况默认为0。对前面的元素赋值后，后面没赋值的默认为0；如果都没赋值，就可能都是随机数。想要给整个数组都赋值为0，只需对第一个元素赋值为0。

#### 二维数组

**定义**：数据类型 数组名[第一维大小] [第二维大小];

**特别提醒**：如果数组大小较大（10^6级别），则需要将其定义在主函数外面，否则会使程序异常退出。原因是函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。

#### memset——对数组中每一个元素赋相同的值

memset函数的格式为：memset(数组名，值，sizeof(数组名));

使用memset需要添加string.h头文件，建议初学者只用memset赋0或-1。因为memset使用的是按字节赋值，即对每个字节赋同样的值，这样组成int型的4个字节就会被赋成相同的值。由于0的二进制补码为全0，-1的二进制补码为全1，不容易弄错。赋其他数字请使用fill函数（但是memset函数速度快）。

#### 字符数组

**字符数组的初始化**：

​		①和普通数组一样

​		②直接赋值字符串来初始化（仅限于初始化，程序其他位置不允许这样直接赋值整个字符串）

**字符数组的输入输出：**

​		①scanf输入，printf输出：

​			%c用来输入单个字符，%s用来输入一个字符串并存在字符数组中。%c能识别空格和换行符，%s通过空格或换行来识别一个字符串的结束。scanf使用%s时不需要&。

​		②getchar输入，putchar输出：

​			用来输入和输出单个字符

​		③gets输入，puts输出

​			gets用来输入一行字符串（gets识别换行符\n作为输入结束，因此scanf完一个整数后，如果使用gets，需要先用getchar接收整数后的换行符），并将其放于一维数组中；puts用来输出一行字符串，即将一维数组在界面上输出，并紧跟一个换行。

**字符数组的存放方式**

​	1、在一维字符数组的末尾都有一个空字符\0，以表示存放的字符串的结尾

​	2、空字符\0在使用gets或scanf输入字符串时会自动添加在输入的字符串后面，并占用一个字符位

​	3、puts和printf通过识别\0作为字符串的结尾来输出

​	4、char数组：字符数组的长度一定要比实际存储字符串的长度至少多1

​	5、\0和空格不是一个东西，\0 的ASCII码位0，即空字符NULL，占用一个字符位，空格的ASCII码为32

​	6、如果不是使用scanf函数的%s格式或gets函数输入字符串（例如使用getchar），请一定要在输入的每个字符串后加入\0，否则printf和puts输出字符串会因无法识别字符串末尾而输出一大堆乱码



#### string.h文件

​	①**strlen()**：得到字符数组中**第一个\0前**的字符的个数

​	②**strcmp()**：返回两个字符串**大小的比较**结果，比较原则是按字典序

​			如果1<2，则返回一个负整数

​			如果1==2，则返回0

​			如果1>2，则返回一个正整数

​	③**strcpy()**：把一个字符串复制给另一个字符串（复制包括结束符\\0）

​	④**strcat()**：可以把一个字符串接到另一个字符串后面

#### sscanf与sprintf

​	sscanf：string+scanf；sprintf：string+printf；均在stdio.h头文件下

```c++
sscanf(str, "%d", &n);
sprintf(str, "%d", n);
```

复杂格式的输入和输出示例：

```c++
#include<stdio.h>
int main()
{
    int n;
    double db;
    char str[100] = "2048:3.14,hello", str2[100];
    sscanf(str, "%d:%lf,%s", &n, &db, str2);
    printf("n = %d, db = %.2f, str2 = %s\n", n, db, str2);
    return 0;
}
```

输出结果：

```c++
n =  2048, db = 3.14, str2 = hello
```

sscanf还支持正则表达式

### 函数

#### 基础

​	**全局变量**：在定义之后的所有程序段内都有效的变量

​	**局部变量**：定义在函数内部，只在函数内部生效，函数结束时局部变量销毁

​	**main函数**返回0的意义在于告知系统程序正常终止

#### 以数组作为函数参数

​		数组作为参数时，参数中数组的第一维不需要填写长度（如果是二维数组，第二维需要填写长度），实际调用时只需要写数组名。**数组作为参数时，在函数中对数组元素的修改等于对原数组元素的修改**（与普通的局部变量不同）。示例如下：

```c++
#include<stdio.h>

void change(int a[], int b[][5])
{
	a[0] = 1;
	a[1] = 3;
	a[2] = 5;
	b[0][0] = 1;
}

int main()
{
	int a[3] = {0};
	int b[5][5] = {0};
	change(a, b);
	for(int i = 0; i < 3; i++)
    {
        printf("%d\n", a[i]);
    }
    return 0;
}
```

输出结果：

```
1
3
5
```

​	数组可以作为参数，但是**不允许作为返回类型出现**。想要返回数组，只能用上面的方法，**将想要返回的数组作为参数传入**。

### 指针

#### 什么是指针

​		计算机通过地址找到变量。**变量的地址一般指它占用的字节第一个字节的地址**，也就是说，一个**int**型的变量的地址就是它占用的字节中第一个字节的地址。

​		C语言中用“指针”来表示内存地址（或者称**指针指向了内存地址**），如果这个内存地址恰好是某个变量的地址，又称“这个指针指向该变量”。

​		在变量前加上**&**就表示变量的地址。

​		指针是一个**unsigned类型**的整数。

#### 指针变量

在下面的定义中，只有**p1**是**int***型的，而**p2**是**int**型的：

```c++
int* p1, p2;
```

应该这样定义：

```c++
int *p1, *p2;
```

注意：**int***是变量类型，**p**是变量名。地址**&a**是赋值给**p**的，而不是 ***p**。 ***p**可以得到**a**的值。

指针变量可以做加减法。**p+1**指的是**p**所指向的型变量的下一个**int**型变量地址。指针变量支持自增和自减操作。

#### 指针与数组

**a[0]**的地址为**&a[0]**，即数组**a**的首地址为**&a[0]**。

数组名称也作为数组的首地址使用，有**a==&a[0]**

推出**a+i**等同于**&a[i]**

数组名a是直接作为数组a的首元素地址，p和q分别是&a[0]与&a[5]，q-p是指两个地址之间的距离，这个距离以int为单位。**两个int型的指针相减，等价于在求两个指针之间相差了几个int。**（其他类型的指针同样适用）

#### 使用指针变量作为函数参数

指针类型作为函数参数的类型，**视为把变量的地址传入函数**。如果在函数中对这个地址中的元素进行改变，原先的数据就会被改变。

#### 引用

引用不产生副本，而是给原变量起了个别名。**对引用变量的操作就是对原变量的操作**。

不管是否使用引用，函数的参数名和实际传入的参数名可以不同。

**注意**：要把引用的**&**和取地址运算符**&**区分开，引用并不是取地址的意思。

引用是产生**变量**的别名，因此**常量不可使用引用**。

### 结构体

#### 结构体的定义

把studentInfo类型定义为：

```c++
struct studentInfo{
	int id;
    char name[20];
    studentInfo* next;
}stu, *p;
```

studentInfo中多了一个指针next用来指向下一个学生的地址，结构体变量中定义了普通变量stu和指针变量p。

#### 访问结构体中的元素

访问stu中变量的写法：

```c++
stu.id
stu.name
stu.next
```

访问p中变量的写法：

```
(*p).id
(*p).name
(*p).next
```

也可以写为：

```
p->id
p->name
p->next
```

#### 结构体初始化

构造函数：初始化结构体的一种函数。不需要写返回函数，函数名与结构体名相同。

对一个普通定义的结构体，其内部会生成一个默认的构造函数（但不可见）。由于这个构造函数的存在，才可以直接定义studentInfo类型的变量而不进行初始化（因为它没有让用户提供任何初始化参数）

```c++
struct studentInfo{
    int id;
    char gender;
    //默认生成的构造函数
    studentInfo(){}
};
```

想要手动提供id和gender的初始化参数，需要像下面这样提供初始化参数来对结构体内的变量进行赋值即可，其中_id和_gender都是变量名。只要不和已有的变量冲突，用a、b或者其他变量名也可以。

```c++
struct studentInfo{
    int id;
    char gender;
    //下面的参数用以对结构体内部变量进行赋值
    studentInfo(int _id, char _gender){
        //赋值
        id = _id;
        gender = _gender;
    }
};
```

构造函数也可以简化为一行：

```c++
struct studentInfo{
	int id;
    char gender;
    studentInfo(int _id, char _gender): id(_id), gender(_gender){}
};
```

这样就可以在需要的时候直接对结构体变量进行赋值了：

```c++
studentInfo stu = studentInfo(10086, 'M');
```

**注意**：如果自己重新定义了构造函数，则不能不经过初始化就定义结构体变量。可以定义多个构造函数。

### 补充

#### cin与cout

如果想读入一整行，则需要使用getline函数，例如下面的代码就把一整行都读入char型数组str[100]中

```c++
char str[100];
cin.getline(str, 100);
```

如果是string容器，则需要用以下方式：

```c++
string str;
getline(cin, str);
```

想控制double型的精度，需要加上一点东西。要加上#include<iomanip>头文件

```c++
cout << setiosflags(ios::fixed) << setprecision(2) << 123.4567 <<endl;
```

对于考试不推荐使用cin和cout，它们在输入输出大量数据的情况下表现非常糟糕，有时题目的数据还没有输入完毕就已经超时。

#### 浮点数的比较

```c++
const double eps = 1e-8;
const double Pi = acos(-1.0);

#define Equ(a,b) ((fabs((a)-(b)))<(eps))
#define More(a,b) (((a)-(b))>(eps))
#define Less(a,b) (((a)-(b))<(-eps))
#define MoreEqu(a,b) (((a)-(b))>(-eps))
#define LessEqu(a,b) (((a)-(b))<(eps))
```

注意：

①由于精度问题，在经过大量运算后，可能变量中存储的0是个很小的负数，如果对其开根号sqrt，就会因不在定义域内而出错。同样的问题还会出现在asin(x)当x存放+1、acos(x)存放-1时。这种情况需要用eps使变量保证在定义域内。

②在某些由编译环境产生的原因下，本应为0.00的变量在输出时会变成-0.00。这个问题是编译环境本身的bug，只能把结果存放到字符串中，然后与-0.00进行比较，如果对比成功，则加上eps来修正为0.00。

#### 复杂度

在时间复杂度中，高等级的幂次会覆盖低等级的幂次。

时间复杂度O(1)<O(logn)<O(n)<O(n^2)

考虑到空间一般够用，因此常常采用以空间换时间的策略。

#### 黑盒测试

单点测试：对该组数据通过了测试就获得这组数据的分值

多点测试：只要有一组数据输出错误，就是0分

